1. ConcurrentHashMap and CopyOnWriteArrayList are two weakly consistent/fail safe collection classes.
	In case of fail fast collections whenever we call next() method first it will check the value of of 
	"modCount" which indicate that the collection is changed or not, If the the value of modCount is not 
	as same as before then it will throw ConcurrentModificationException.

2. Queue In Collection :-
    2.1 -> Diff between poll() and remove() method in Queue interface is poll() method return null if queue is empty.
		but remove() method throw java.util.NoSuchElementException exception.
		
3. UnSupportedException comes when you try to add the value in UnModifiedCollection. Basically it means JVM is preventing 
	you to perform some operation.
	
4. Default size of Queue is 11.

5. Default size of HashMap bucket is 16.

6. ConcurrentHashMap provides better performance by locking only the portion of the map rather than blocking the whole
	map resulting in greater shared access, it does not allow null key or null value.
	
	a. ReentrantLock lock for locking macanism.
	b. default capacity = 16
	c. loadfactor = 0.75
	d. cuncurrency level = 16
	e. it is better choice more reads then write.
	
7. Important points about TreeSet :-
	a. In order to add custom or user defined objects to TreeSet data structure, the custom class should implement the Comparable 
	   interface or a Comparator should be passed to TreeSet constructor during creation. This is required because TreeSet does not allow 
	   duplicate elements and to ensure this with custom objects, TreeSet requires a comparator function to perform the comparison 
	   of custom objects. If a comparator is not specified then when you try to add a custom object to TreeSet, it will 
	   throw java.lang.ClassCastException.
	   
8. Homegeneous and Hetrogeneous -> Array have a runtime check on the type of the added element. That is, if a new element that is not of the same type  
	is added, an ArrayStoreException is thrown at runtime. That's why they are considerd as "homegeneous".
	That is not true for ArrayList. Due to type erasure at runtime, it can practically hold any object.
	
9. HashMap java 8 Implementation -> 
	a. But you can't rely on people to implement good hash functions. People will often write poor hash functions which will result in a 
		non-even distribution. It's also possible that we could just get unlucky with our inputs.
	b. The implementation of Hashmap tries to mitigate this by organising some buckets into trees rather than linked lists if the 
		buckets becomes too large. This is what TREEIFY_THRESHOLD = 8 is for. If a bucket contains more than eight items, 
		it should become a tree.
	c. This tree is a Red-Black tree. It is first sorted by hash code. If the hash codes are the same, it uses the compareTo 
		method of Comparable if the objects implement that interface, else the identity hash code.
	d.If entries are removed from the map, the number of entries in the bucket might reduce such that this tree structure is no 
		longer necessary. That's what the UNTREEIFY_THRESHOLD = 6 is for. If the number of elements in a bucket drops below six,
		we might as well go back to using a linked list.
