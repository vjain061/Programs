1. ConcurrentHashMap and CopyOnWriteArrayList are two weakly consistent/fail safe collection classes.
	In case of fail fast collections whenever we call next() method first it will check the value of of 
	"modCount" which indicate that the collection is changed or not, If the the value of modCount is not 
	as same as before then it will throw ConcurrentModificationException.

2. Queue In Collection :-
    2.1 -> Diff between poll() and remove() method in Queue interface is poll() method return null if queue is empty.
		but remove() method throw java.util.NoSuchElementException exception.
		
3. UnSupportedException comes when you try to add the value in UnModifiedCollection. Basically it means JVM is preventing 
	you to perform some operation.
	
4. Default size of Queue is 11.

5. Default size of HashMap bucket is 16.

6. ConcurrentHashMap provides better performance by locking only the portion of the map rather than blocking the whole
	map resulting in greater shared access, it does not allow null key or null value.
	
	a. ReentrantLock lock for locking macanism.
	b. default capacity = 16
	c. loadfactor = 0.75
	d. cuncurrency level = 16
	e. it is better choice more reads then write.
	
7. Important points about TreeSet :-
	a. In order to add custom or user defined objects to TreeSet data structure, the custom class should implement the Comparable 
	   interface or a Comparator should be passed to TreeSet constructor during creation. This is required because TreeSet does not allow 
	   duplicate elements and to ensure this with custom objects, TreeSet requires a comparator function to perform the comparison 
	   of custom objects. If a comparator is not specified then when you try to add a custom object to TreeSet, it will 
	   throw java.lang.ClassCastException.
	   
8. Homegeneous and Hetrogeneous -> Array have a runtime check on the type of the added element. That is, if a new element that is not of the same type  
	is added, an ArrayStoreException is thrown at runtime. That's why they are considerd as "homegeneous".
	That is not true for ArrayList. Due to type erasure at runtime, it can practically hold any object.
